// -*- mode: java -*-

class BurstAnimation
{
	float x;
	float y;
	float z;

	float start_shrinking;
	float stop_shrinking;
	float shrink_factor;
	float start_growing;
	float stop_growing;
	float grow_factor;

  float ScaleFactor (float t)
  {
	if (t > stop_shrinking)
 	{
		return 0;
 	} 
 	else if (t > start_shrinking)
 	{
		return 1.0 - ((t - start_shrinking) * shrink_factor);
 	}
 	else if (t > stop_growing)
 	{
		return 1.0;
 	}
 	else if (t > start_growing)
 	{
		return (t - start_growing) * grow_factor; 
 	}
  	// So <= start_growing
  	return  0.0;
  }


void Draw (float t)
{
	float scale_factor = ScaleFactor (t); 
	if (scale_factor < ts[which])
  	{
		return; 
  	}
  	float scale_scaled = (scale_factor - ts[which]) * t_scale_factors[which];
  	float side_length = sizes[which] * scale_scaled;
  	if (side_length > sizes[which])
  	{
		side_length = sizes[which]; 
  	}
  	translate (x * scale_scaled, y * scale_scaled, z * scale_scaled);
  	scale (scale_factor);
}

Entity MakeEntity ()
{
	// Generate final position
	// Generate starting position by extending XYz
	// Make entity at starting position
	// Make animation to interpolate
	// Animation should *set* XYZ, not add to? So AbsoluteAnimation
}

class Sequence
{
	Entity[] entities

	float rotation;

	// The current object population timeline

	float start_growing;
	float stop_growing;
	float start_shrinking;
	float stop_shrinking;

	float grow_factor;
	float shrink_factor;

   Sequence ()
   {
	rotation = random (PI / 2.0);
  
	int num_objects = (int)random(min_objects, max_objects);
	entities = new Entity[num_objects];
  
	for (int i = 0; i < num_objects; i++) 
  	{
		enities	
	}	
  }


  float random_duration ()
  {
	return random (min_duration, max_duration) * 1000; 
  }

  // make the timeline for the objects

  void gen_timeline ()
  {
	start_growing = millis ();
  	stop_growing = start_growing + random_duration ();
  	start_shrinking = stop_growing + random_duration ();
  	stop_shrinking = start_shrinking + random_duration ();
  
	grow_factor = 1.0 / (stop_growing - start_growing);
  	shrink_factor = 1.0 / (stop_shrinking - start_shrinking);
  }

 
  
void draw_object (int which, float scale_factor)
{
  if (scale_factor < ts[which])
  {
    return; 
  }
  float scale_scaled = (scale_factor - ts[which]) * t_scale_factors[which];
  float side_length = sizes[which] * scale_scaled;
  if (side_length > sizes[which])
  {
   side_length = sizes[which]; 
  }
  fill (220);//(shades[which]);
  pushMatrix ();
  translate (xs[which] * scale_scaled, ys[which] * scale_scaled, zs[which] * scale_scaled);
  rotateX (- PI / 8.0);
  rotateY (PI / 8.0);
  box (side_length);
  popMatrix ();
}

void draw_objects ()
{
  float now = millis ();
  float scale_factor = scale_factor (now);
  if (scale_factor == 0)
  {
   gen_objects ();
   gen_timeline ();
  }
  for (int i = 0; i < num_objects; i++)
  {
   draw_object (i, scale_factor);
  } 
}

void setup ()
{
  size(canvas_width, canvas_height, P3D); 
  frameRate(30);
  gen_objects ();
  gen_timeline ();
}

void draw ()
{
  background(255);
  ambientLight (245, 245, 245);
  directionalLight (50, 50, 50, 0, 1, -1);
  translate (canvas_width / 2.0, canvas_height / 2.0,
             - (max (canvas_width, canvas_height) * 0.4));
  noStroke ();
  draw_objects ();   
}
